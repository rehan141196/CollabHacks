{"version":3,"sources":["uuid-utils.js"],"names":["constructHydraId","deconstructHydraId","buildHydraMessageId","buildHydraPersonId","buildHydraRoomId","buildHydraOrgId","buildHydraMembershipId","getHydraRoomType","getHydraFiles","hydraBaseResource","hydraBaseUrl","type","id","toUpperCase","payload","split","pop","uuid","hydraTypes","MESSAGE","PEOPLE","ROOM","ORGANIZATION","personUUID","spaceUUID","MEMBERSHIP","tags","includes","SDK_EVENT","INTERNAL","ACTIVITY_TAG","ONE_ON_ONE","EXTERNAL","SPACE_TYPE","DIRECT","GROUP","activity","hydraFiles","files","object","items","i","length","contentId","CONTENT","push"],"mappings":";;;;;QAcgBA,gB,GAAAA,gB;QAWAC,kB,GAAAA,kB;QAgBAC,mB,GAAAA,mB;QAWAC,kB,GAAAA,kB;QAWAC,gB,GAAAA,gB;QAWAC,e,GAAAA,e;QAaAC,sB,GAAAA,sB;QAaAC,gB,GAAAA,gB;QAeAC,a,GAAAA,a;;AAnHhB;;AACA;;AAEA,IAAMC,oBAAoB,iBAA1B;AACA,IAAMC,eAAe,+BAArB;;AAEA;;;;;;;;AAQO,SAASV,gBAAT,CAA0BW,IAA1B,EAAgCC,EAAhC,EAAoC;AACzC,SAAO,kBAAUH,iBAAV,SAA+BE,KAAKE,WAAL,EAA/B,SAAqDD,EAArD,CAAP;AACD;;AAED;;;;;;;AAOO,SAASX,kBAAT,CAA4BW,EAA5B,EAAgC;AACrC,MAAME,UAAU,kBAAOF,EAAP,EAAWG,KAAX,CAAiB,GAAjB,CAAhB;;AAEA,SAAO;AACLH,QAAIE,QAAQE,GAAR,EADC;AAELL,UAAMG,QAAQE,GAAR;AAFD,GAAP;AAID;;AAED;;;;;;;AAOO,SAASd,mBAAT,CAA6Be,IAA7B,EAAmC;AACxC,SAAOjB,iBAAiBkB,sBAAWC,OAA5B,EAAqCF,IAArC,CAAP;AACD;;AAED;;;;;;;AAOO,SAASd,kBAAT,CAA4Bc,IAA5B,EAAkC;AACvC,SAAOjB,iBAAiBkB,sBAAWE,MAA5B,EAAoCH,IAApC,CAAP;AACD;;AAED;;;;;;;AAOO,SAASb,gBAAT,CAA0Ba,IAA1B,EAAgC;AACrC,SAAOjB,iBAAiBkB,sBAAWG,IAA5B,EAAkCJ,IAAlC,CAAP;AACD;;AAED;;;;;;;AAOO,SAASZ,eAAT,CAAyBY,IAAzB,EAA+B;AACpC,SAAOjB,iBAAiBkB,sBAAWI,YAA5B,EAA0CL,IAA1C,CAAP;AACD;;AAED;;;;;;;;;AASO,SAASX,sBAAT,CAAgCiB,UAAhC,EAA4CC,SAA5C,EAAuD;AAC5D,SAAOxB,iBAAiBkB,sBAAWO,UAA5B,EACFF,UADE,SACYC,SADZ,CAAP;AAED;;AAED;;;;;;;;AAQO,SAASjB,gBAAT,CAA0BmB,IAA1B,EAAgC;AACrC,MAAIA,KAAKC,QAAL,CAAcC,qBAAUC,QAAV,CAAmBC,YAAnB,CAAgCC,UAA9C,CAAJ,EAA+D;AAC7D,WAAOH,qBAAUI,QAAV,CAAmBC,UAAnB,CAA8BC,MAArC;AACD;;AAED,SAAON,qBAAUI,QAAV,CAAmBC,UAAnB,CAA8BE,KAArC;AACD;;AAED;;;;;;;AAOO,SAAS3B,aAAT,CAAuB4B,QAAvB,EAAiC;AACtC,MAAMC,aAAa,EAAnB;AADsC,MAE/BC,KAF+B,GAEtBF,SAASG,MAFa,CAE/BD,KAF+B;;;AAItC,MAAIA,KAAJ,EAAW;AAAA,QACFE,KADE,GACOF,KADP,CACFE,KADE;;AAGT;;AACA,SAAK,IAAIC,IAAI,CAAb,EAAgBA,IAAID,MAAME,MAA1B,EAAkCD,KAAK,CAAvC,EAA0C;AACxC,UAAME,YACJ3C,iBAAiBkB,sBAAW0B,OAA5B,EAAwCR,SAASxB,EAAjD,SAAuD6B,CAAvD,CADF;;AAGAJ,iBAAWQ,IAAX,CAAmBnC,YAAnB,kBAA4CiC,SAA5C;AACD;AACF;;AAED,SAAON,UAAP;AACD","file":"uuid-utils.js","sourcesContent":["import {encode, decode} from './base64';\nimport {SDK_EVENT, hydraTypes} from './constants';\n\nconst hydraBaseResource = 'ciscospark://us';\nconst hydraBaseUrl = 'https://api.ciscospark.com/v1';\n\n/**\n * Constructs a Hydra ID for a given UUID and type.\n *\n * @export\n * @param {string} type one of PEOPLE, TEAM, ROOM\n * @param {any} id\n * @returns {string}\n */\nexport function constructHydraId(type, id) {\n  return encode(`${hydraBaseResource}/${type.toUpperCase()}/${id}`);\n}\n\n/**\n * Deconstructs a Hydra ID and provides the UUID.\n *\n * @export\n * @param {String} id\n * @returns {String}\n */\nexport function deconstructHydraId(id) {\n  const payload = decode(id).split('/');\n\n  return {\n    id: payload.pop(),\n    type: payload.pop()\n  };\n}\n\n/**\n * Constructs a Hydra ID for a message based on internal UUID\n *\n * @export\n * @param {any} uuid\n * @returns {string}\n */\nexport function buildHydraMessageId(uuid) {\n  return constructHydraId(hydraTypes.MESSAGE, uuid);\n}\n\n/**\n * Constructs a Hydra ID for a person based on internal UUID\n *\n * @export\n * @param {any} uuid\n * @returns {string}\n */\nexport function buildHydraPersonId(uuid) {\n  return constructHydraId(hydraTypes.PEOPLE, uuid);\n}\n\n/**\n * Constructs a Hydra ID for a room based on internal UUID\n *\n * @export\n * @param {any} uuid\n * @returns {string}\n */\nexport function buildHydraRoomId(uuid) {\n  return constructHydraId(hydraTypes.ROOM, uuid);\n}\n\n/**\n * Constructs a Hydra ID for an organization based on internal UUID\n *\n * @export\n * @param {any} uuid\n * @returns {string}\n */\nexport function buildHydraOrgId(uuid) {\n  return constructHydraId(hydraTypes.ORGANIZATION, uuid);\n}\n\n/**\n * Constructs a Hydra ID for an membership based on an\n * internal UUID for the person, and the space\n *\n * @export\n * @param {any} personUUID\n * @param {any} spaceUUID\n * @returns {string}\n */\nexport function buildHydraMembershipId(personUUID, spaceUUID) {\n  return constructHydraId(hydraTypes.MEMBERSHIP,\n    `${personUUID}:${spaceUUID}`);\n}\n\n/**\n * Returns a Hydra roomType based on conversation tags\n *\n * @export\n * @param {arra} tags\n * @param {any} spaceUUID\n * @returns {string}\n */\nexport function getHydraRoomType(tags) {\n  if (tags.includes(SDK_EVENT.INTERNAL.ACTIVITY_TAG.ONE_ON_ONE)) {\n    return SDK_EVENT.EXTERNAL.SPACE_TYPE.DIRECT;\n  }\n\n  return SDK_EVENT.EXTERNAL.SPACE_TYPE.GROUP;\n}\n\n/**\n * Returns file URLs for the activity, adhering to Hydra details,\n * e.g., https://api.ciscospark.com/v1/contents/Y2lzY29zcGF...\n * @see https://developer.webex.com/docs/api/v1/messages/get-message-details\n * @param {Object} activity from mercury\n * @returns {Array} file URLs\n */\nexport function getHydraFiles(activity) {\n  const hydraFiles = [];\n  const {files} = activity.object;\n\n  if (files) {\n    const {items} = files;\n\n    // Note: Generated ID is dependent on file order.\n    for (let i = 0; i < items.length; i += 1) {\n      const contentId =\n        constructHydraId(hydraTypes.CONTENT, `${activity.id}/${i}`);\n\n      hydraFiles.push(`${hydraBaseUrl}/contents/${contentId}`);\n    }\n  }\n\n  return hydraFiles;\n}\n"]}